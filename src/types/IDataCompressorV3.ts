/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "./common";

export type PriceOnDemandStruct = { token: AddressLike; callData: BytesLike };

export type PriceOnDemandStructOutput = [token: string, callData: string] & {
  token: string;
  callData: string;
};

export type TokenBalanceStruct = {
  token: AddressLike;
  balance: BigNumberish;
  isForbidden: boolean;
  isEnabled: boolean;
  isQuoted: boolean;
  quota: BigNumberish;
  quotaRate: BigNumberish;
  quotaCumulativeIndexLU: BigNumberish;
};

export type TokenBalanceStructOutput = [
  token: string,
  balance: bigint,
  isForbidden: boolean,
  isEnabled: boolean,
  isQuoted: boolean,
  quota: bigint,
  quotaRate: bigint,
  quotaCumulativeIndexLU: bigint
] & {
  token: string;
  balance: bigint;
  isForbidden: boolean;
  isEnabled: boolean;
  isQuoted: boolean;
  quota: bigint;
  quotaRate: bigint;
  quotaCumulativeIndexLU: bigint;
};

export type CreditAccountDataStruct = {
  isSuccessful: boolean;
  priceFeedsNeeded: AddressLike[];
  addr: AddressLike;
  borrower: AddressLike;
  creditManager: AddressLike;
  cmName: string;
  creditFacade: AddressLike;
  underlying: AddressLike;
  debt: BigNumberish;
  cumulativeIndexLastUpdate: BigNumberish;
  cumulativeQuotaInterest: BigNumberish;
  accruedInterest: BigNumberish;
  accruedFees: BigNumberish;
  totalDebtUSD: BigNumberish;
  totalValue: BigNumberish;
  totalValueUSD: BigNumberish;
  twvUSD: BigNumberish;
  enabledTokensMask: BigNumberish;
  healthFactor: BigNumberish;
  baseBorrowRate: BigNumberish;
  aggregatedBorrowRate: BigNumberish;
  balances: TokenBalanceStruct[];
  since: BigNumberish;
  cfVersion: BigNumberish;
  expirationDate: BigNumberish;
  activeBots: AddressLike[];
};

export type CreditAccountDataStructOutput = [
  isSuccessful: boolean,
  priceFeedsNeeded: string[],
  addr: string,
  borrower: string,
  creditManager: string,
  cmName: string,
  creditFacade: string,
  underlying: string,
  debt: bigint,
  cumulativeIndexLastUpdate: bigint,
  cumulativeQuotaInterest: bigint,
  accruedInterest: bigint,
  accruedFees: bigint,
  totalDebtUSD: bigint,
  totalValue: bigint,
  totalValueUSD: bigint,
  twvUSD: bigint,
  enabledTokensMask: bigint,
  healthFactor: bigint,
  baseBorrowRate: bigint,
  aggregatedBorrowRate: bigint,
  balances: TokenBalanceStructOutput[],
  since: bigint,
  cfVersion: bigint,
  expirationDate: bigint,
  activeBots: string[]
] & {
  isSuccessful: boolean;
  priceFeedsNeeded: string[];
  addr: string;
  borrower: string;
  creditManager: string;
  cmName: string;
  creditFacade: string;
  underlying: string;
  debt: bigint;
  cumulativeIndexLastUpdate: bigint;
  cumulativeQuotaInterest: bigint;
  accruedInterest: bigint;
  accruedFees: bigint;
  totalDebtUSD: bigint;
  totalValue: bigint;
  totalValueUSD: bigint;
  twvUSD: bigint;
  enabledTokensMask: bigint;
  healthFactor: bigint;
  baseBorrowRate: bigint;
  aggregatedBorrowRate: bigint;
  balances: TokenBalanceStructOutput[];
  since: bigint;
  cfVersion: bigint;
  expirationDate: bigint;
  activeBots: string[];
};

export type ContractAdapterStruct = {
  targetContract: AddressLike;
  adapter: AddressLike;
};

export type ContractAdapterStructOutput = [
  targetContract: string,
  adapter: string
] & { targetContract: string; adapter: string };

export type QuotaInfoStruct = {
  token: AddressLike;
  rate: BigNumberish;
  quotaIncreaseFee: BigNumberish;
  totalQuoted: BigNumberish;
  limit: BigNumberish;
  isActive: boolean;
};

export type QuotaInfoStructOutput = [
  token: string,
  rate: bigint,
  quotaIncreaseFee: bigint,
  totalQuoted: bigint,
  limit: bigint,
  isActive: boolean
] & {
  token: string;
  rate: bigint;
  quotaIncreaseFee: bigint;
  totalQuoted: bigint;
  limit: bigint;
  isActive: boolean;
};

export type LinearModelStruct = {
  interestModel: AddressLike;
  version: BigNumberish;
  U_1: BigNumberish;
  U_2: BigNumberish;
  R_base: BigNumberish;
  R_slope1: BigNumberish;
  R_slope2: BigNumberish;
  R_slope3: BigNumberish;
  isBorrowingMoreU2Forbidden: boolean;
};

export type LinearModelStructOutput = [
  interestModel: string,
  version: bigint,
  U_1: bigint,
  U_2: bigint,
  R_base: bigint,
  R_slope1: bigint,
  R_slope2: bigint,
  R_slope3: bigint,
  isBorrowingMoreU2Forbidden: boolean
] & {
  interestModel: string;
  version: bigint;
  U_1: bigint;
  U_2: bigint;
  R_base: bigint;
  R_slope1: bigint;
  R_slope2: bigint;
  R_slope3: bigint;
  isBorrowingMoreU2Forbidden: boolean;
};

export type CreditManagerDataStruct = {
  addr: AddressLike;
  name: string;
  cfVersion: BigNumberish;
  creditFacade: AddressLike;
  creditConfigurator: AddressLike;
  underlying: AddressLike;
  pool: AddressLike;
  totalDebt: BigNumberish;
  totalDebtLimit: BigNumberish;
  baseBorrowRate: BigNumberish;
  minDebt: BigNumberish;
  maxDebt: BigNumberish;
  availableToBorrow: BigNumberish;
  collateralTokens: AddressLike[];
  adapters: ContractAdapterStruct[];
  liquidationThresholds: BigNumberish[];
  isDegenMode: boolean;
  degenNFT: AddressLike;
  forbiddenTokenMask: BigNumberish;
  maxEnabledTokensLength: BigNumberish;
  feeInterest: BigNumberish;
  feeLiquidation: BigNumberish;
  liquidationDiscount: BigNumberish;
  feeLiquidationExpired: BigNumberish;
  liquidationDiscountExpired: BigNumberish;
  quotas: QuotaInfoStruct[];
  lirm: LinearModelStruct;
  isPaused: boolean;
};

export type CreditManagerDataStructOutput = [
  addr: string,
  name: string,
  cfVersion: bigint,
  creditFacade: string,
  creditConfigurator: string,
  underlying: string,
  pool: string,
  totalDebt: bigint,
  totalDebtLimit: bigint,
  baseBorrowRate: bigint,
  minDebt: bigint,
  maxDebt: bigint,
  availableToBorrow: bigint,
  collateralTokens: string[],
  adapters: ContractAdapterStructOutput[],
  liquidationThresholds: bigint[],
  isDegenMode: boolean,
  degenNFT: string,
  forbiddenTokenMask: bigint,
  maxEnabledTokensLength: bigint,
  feeInterest: bigint,
  feeLiquidation: bigint,
  liquidationDiscount: bigint,
  feeLiquidationExpired: bigint,
  liquidationDiscountExpired: bigint,
  quotas: QuotaInfoStructOutput[],
  lirm: LinearModelStructOutput,
  isPaused: boolean
] & {
  addr: string;
  name: string;
  cfVersion: bigint;
  creditFacade: string;
  creditConfigurator: string;
  underlying: string;
  pool: string;
  totalDebt: bigint;
  totalDebtLimit: bigint;
  baseBorrowRate: bigint;
  minDebt: bigint;
  maxDebt: bigint;
  availableToBorrow: bigint;
  collateralTokens: string[];
  adapters: ContractAdapterStructOutput[];
  liquidationThresholds: bigint[];
  isDegenMode: boolean;
  degenNFT: string;
  forbiddenTokenMask: bigint;
  maxEnabledTokensLength: bigint;
  feeInterest: bigint;
  feeLiquidation: bigint;
  liquidationDiscount: bigint;
  feeLiquidationExpired: bigint;
  liquidationDiscountExpired: bigint;
  quotas: QuotaInfoStructOutput[];
  lirm: LinearModelStructOutput;
  isPaused: boolean;
};

export type GaugeQuotaParamsStruct = {
  token: AddressLike;
  minRate: BigNumberish;
  maxRate: BigNumberish;
  totalVotesLpSide: BigNumberish;
  totalVotesCaSide: BigNumberish;
  rate: BigNumberish;
  quotaIncreaseFee: BigNumberish;
  totalQuoted: BigNumberish;
  limit: BigNumberish;
  isActive: boolean;
  stakerVotesLpSide: BigNumberish;
  stakerVotesCaSide: BigNumberish;
};

export type GaugeQuotaParamsStructOutput = [
  token: string,
  minRate: bigint,
  maxRate: bigint,
  totalVotesLpSide: bigint,
  totalVotesCaSide: bigint,
  rate: bigint,
  quotaIncreaseFee: bigint,
  totalQuoted: bigint,
  limit: bigint,
  isActive: boolean,
  stakerVotesLpSide: bigint,
  stakerVotesCaSide: bigint
] & {
  token: string;
  minRate: bigint;
  maxRate: bigint;
  totalVotesLpSide: bigint;
  totalVotesCaSide: bigint;
  rate: bigint;
  quotaIncreaseFee: bigint;
  totalQuoted: bigint;
  limit: bigint;
  isActive: boolean;
  stakerVotesLpSide: bigint;
  stakerVotesCaSide: bigint;
};

export type GaugeInfoStruct = {
  addr: AddressLike;
  pool: AddressLike;
  symbol: string;
  name: string;
  underlying: AddressLike;
  currentEpoch: BigNumberish;
  epochFrozen: boolean;
  quotaParams: GaugeQuotaParamsStruct[];
};

export type GaugeInfoStructOutput = [
  addr: string,
  pool: string,
  symbol: string,
  name: string,
  underlying: string,
  currentEpoch: bigint,
  epochFrozen: boolean,
  quotaParams: GaugeQuotaParamsStructOutput[]
] & {
  addr: string;
  pool: string;
  symbol: string;
  name: string;
  underlying: string;
  currentEpoch: bigint;
  epochFrozen: boolean;
  quotaParams: GaugeQuotaParamsStructOutput[];
};

export type CreditManagerDebtParamsStruct = {
  creditManager: AddressLike;
  borrowed: BigNumberish;
  limit: BigNumberish;
  availableToBorrow: BigNumberish;
};

export type CreditManagerDebtParamsStructOutput = [
  creditManager: string,
  borrowed: bigint,
  limit: bigint,
  availableToBorrow: bigint
] & {
  creditManager: string;
  borrowed: bigint;
  limit: bigint;
  availableToBorrow: bigint;
};

export type ZapperInfoStruct = {
  zapper: AddressLike;
  tokenIn: AddressLike;
  tokenOut: AddressLike;
};

export type ZapperInfoStructOutput = [
  zapper: string,
  tokenIn: string,
  tokenOut: string
] & { zapper: string; tokenIn: string; tokenOut: string };

export type PoolDataStruct = {
  addr: AddressLike;
  underlying: AddressLike;
  dieselToken: AddressLike;
  symbol: string;
  name: string;
  baseInterestIndex: BigNumberish;
  availableLiquidity: BigNumberish;
  expectedLiquidity: BigNumberish;
  totalBorrowed: BigNumberish;
  totalDebtLimit: BigNumberish;
  creditManagerDebtParams: CreditManagerDebtParamsStruct[];
  totalAssets: BigNumberish;
  totalSupply: BigNumberish;
  supplyRate: BigNumberish;
  baseInterestRate: BigNumberish;
  dieselRate_RAY: BigNumberish;
  withdrawFee: BigNumberish;
  lastBaseInterestUpdate: BigNumberish;
  baseInterestIndexLU: BigNumberish;
  version: BigNumberish;
  poolQuotaKeeper: AddressLike;
  gauge: AddressLike;
  quotas: QuotaInfoStruct[];
  zappers: ZapperInfoStruct[];
  lirm: LinearModelStruct;
  isPaused: boolean;
};

export type PoolDataStructOutput = [
  addr: string,
  underlying: string,
  dieselToken: string,
  symbol: string,
  name: string,
  baseInterestIndex: bigint,
  availableLiquidity: bigint,
  expectedLiquidity: bigint,
  totalBorrowed: bigint,
  totalDebtLimit: bigint,
  creditManagerDebtParams: CreditManagerDebtParamsStructOutput[],
  totalAssets: bigint,
  totalSupply: bigint,
  supplyRate: bigint,
  baseInterestRate: bigint,
  dieselRate_RAY: bigint,
  withdrawFee: bigint,
  lastBaseInterestUpdate: bigint,
  baseInterestIndexLU: bigint,
  version: bigint,
  poolQuotaKeeper: string,
  gauge: string,
  quotas: QuotaInfoStructOutput[],
  zappers: ZapperInfoStructOutput[],
  lirm: LinearModelStructOutput,
  isPaused: boolean
] & {
  addr: string;
  underlying: string;
  dieselToken: string;
  symbol: string;
  name: string;
  baseInterestIndex: bigint;
  availableLiquidity: bigint;
  expectedLiquidity: bigint;
  totalBorrowed: bigint;
  totalDebtLimit: bigint;
  creditManagerDebtParams: CreditManagerDebtParamsStructOutput[];
  totalAssets: bigint;
  totalSupply: bigint;
  supplyRate: bigint;
  baseInterestRate: bigint;
  dieselRate_RAY: bigint;
  withdrawFee: bigint;
  lastBaseInterestUpdate: bigint;
  baseInterestIndexLU: bigint;
  version: bigint;
  poolQuotaKeeper: string;
  gauge: string;
  quotas: QuotaInfoStructOutput[];
  zappers: ZapperInfoStructOutput[];
  lirm: LinearModelStructOutput;
  isPaused: boolean;
};

export interface IDataCompressorV3Interface extends Interface {
  getFunction(
    nameOrSignature:
      | "getCreditAccountData"
      | "getCreditAccountsByBorrower"
      | "getCreditAccountsByCreditManager"
      | "getCreditManagerData"
      | "getCreditManagersV3List"
      | "getGaugesV3Data"
      | "getLiquidatableCreditAccounts"
      | "getPoolData"
      | "getPoolsV3List"
      | "version"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "getCreditAccountData",
    values: [AddressLike, PriceOnDemandStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getCreditAccountsByBorrower",
    values: [AddressLike, PriceOnDemandStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getCreditAccountsByCreditManager",
    values: [AddressLike, PriceOnDemandStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getCreditManagerData",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getCreditManagersV3List",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getGaugesV3Data",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getLiquidatableCreditAccounts",
    values: [PriceOnDemandStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getPoolData",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getPoolsV3List",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;

  decodeFunctionResult(
    functionFragment: "getCreditAccountData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCreditAccountsByBorrower",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCreditAccountsByCreditManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCreditManagerData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCreditManagersV3List",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getGaugesV3Data",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLiquidatableCreditAccounts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPoolData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPoolsV3List",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
}

export interface IDataCompressorV3 extends BaseContract {
  connect(runner?: ContractRunner | null): IDataCompressorV3;
  waitForDeployment(): Promise<this>;

  interface: IDataCompressorV3Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getCreditAccountData: TypedContractMethod<
    [creditAccount: AddressLike, priceUpdates: PriceOnDemandStruct[]],
    [CreditAccountDataStructOutput],
    "nonpayable"
  >;

  getCreditAccountsByBorrower: TypedContractMethod<
    [borrower: AddressLike, priceUpdates: PriceOnDemandStruct[]],
    [CreditAccountDataStructOutput[]],
    "nonpayable"
  >;

  getCreditAccountsByCreditManager: TypedContractMethod<
    [creditManager: AddressLike, priceUpdates: PriceOnDemandStruct[]],
    [CreditAccountDataStructOutput[]],
    "nonpayable"
  >;

  getCreditManagerData: TypedContractMethod<
    [creditManager: AddressLike],
    [CreditManagerDataStructOutput],
    "view"
  >;

  getCreditManagersV3List: TypedContractMethod<
    [],
    [CreditManagerDataStructOutput[]],
    "view"
  >;

  getGaugesV3Data: TypedContractMethod<
    [staker: AddressLike],
    [GaugeInfoStructOutput[]],
    "view"
  >;

  getLiquidatableCreditAccounts: TypedContractMethod<
    [priceUpdates: PriceOnDemandStruct[]],
    [CreditAccountDataStructOutput[]],
    "nonpayable"
  >;

  getPoolData: TypedContractMethod<
    [_pool: AddressLike],
    [PoolDataStructOutput],
    "view"
  >;

  getPoolsV3List: TypedContractMethod<[], [PoolDataStructOutput[]], "view">;

  version: TypedContractMethod<[], [bigint], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "getCreditAccountData"
  ): TypedContractMethod<
    [creditAccount: AddressLike, priceUpdates: PriceOnDemandStruct[]],
    [CreditAccountDataStructOutput],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getCreditAccountsByBorrower"
  ): TypedContractMethod<
    [borrower: AddressLike, priceUpdates: PriceOnDemandStruct[]],
    [CreditAccountDataStructOutput[]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getCreditAccountsByCreditManager"
  ): TypedContractMethod<
    [creditManager: AddressLike, priceUpdates: PriceOnDemandStruct[]],
    [CreditAccountDataStructOutput[]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getCreditManagerData"
  ): TypedContractMethod<
    [creditManager: AddressLike],
    [CreditManagerDataStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getCreditManagersV3List"
  ): TypedContractMethod<[], [CreditManagerDataStructOutput[]], "view">;
  getFunction(
    nameOrSignature: "getGaugesV3Data"
  ): TypedContractMethod<
    [staker: AddressLike],
    [GaugeInfoStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getLiquidatableCreditAccounts"
  ): TypedContractMethod<
    [priceUpdates: PriceOnDemandStruct[]],
    [CreditAccountDataStructOutput[]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getPoolData"
  ): TypedContractMethod<[_pool: AddressLike], [PoolDataStructOutput], "view">;
  getFunction(
    nameOrSignature: "getPoolsV3List"
  ): TypedContractMethod<[], [PoolDataStructOutput[]], "view">;
  getFunction(
    nameOrSignature: "version"
  ): TypedContractMethod<[], [bigint], "view">;

  filters: {};
}
