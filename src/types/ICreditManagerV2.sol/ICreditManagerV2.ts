/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export interface ICreditManagerV2Interface extends Interface {
  getFunction(
    nameOrSignature:
      | "adapterToContract"
      | "addCollateral"
      | "approveCreditAccount"
      | "calcClosePayments"
      | "calcCreditAccountAccruedInterest"
      | "canLiquidateWhilePaused"
      | "checkAndEnableToken"
      | "checkAndOptimizeEnabledTokens"
      | "checkEmergencyPausable"
      | "closeCreditAccount"
      | "collateralTokens"
      | "collateralTokensByMask"
      | "collateralTokensCount"
      | "contractToAdapter"
      | "creditAccounts"
      | "creditConfigurator"
      | "creditFacade"
      | "cumulativeDropAtFastCheckRAY"
      | "disableToken"
      | "enabledTokensMap"
      | "executeOrder"
      | "fastCollateralCheck"
      | "fees"
      | "forbiddenTokenMask"
      | "fullCollateralCheck"
      | "getCreditAccountOrRevert"
      | "liquidationThresholds"
      | "manageDebt"
      | "maxAllowedEnabledTokenLength"
      | "openCreditAccount"
      | "pool"
      | "poolService"
      | "priceOracle"
      | "tokenMasksMap"
      | "transferAccountOwnership"
      | "underlying"
      | "universalAdapter"
      | "version"
      | "wethAddress"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic: "ExecuteOrder" | "NewConfigurator"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "adapterToContract",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "addCollateral",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "approveCreditAccount",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "calcClosePayments",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "calcCreditAccountAccruedInterest",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "canLiquidateWhilePaused",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "checkAndEnableToken",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "checkAndOptimizeEnabledTokens",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "checkEmergencyPausable",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "closeCreditAccount",
    values: [
      AddressLike,
      BigNumberish,
      BigNumberish,
      AddressLike,
      AddressLike,
      BigNumberish,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "collateralTokens",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "collateralTokensByMask",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "collateralTokensCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "contractToAdapter",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "creditAccounts",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "creditConfigurator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "creditFacade",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cumulativeDropAtFastCheckRAY",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "disableToken",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "enabledTokensMap",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "executeOrder",
    values: [AddressLike, AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fastCollateralCheck",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "fees", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "forbiddenTokenMask",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "fullCollateralCheck",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getCreditAccountOrRevert",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidationThresholds",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "manageDebt",
    values: [AddressLike, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "maxAllowedEnabledTokenLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "openCreditAccount",
    values: [BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "pool", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "poolService",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "priceOracle",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tokenMasksMap",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferAccountOwnership",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "underlying",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "universalAdapter",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "wethAddress",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "adapterToContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveCreditAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calcClosePayments",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calcCreditAccountAccruedInterest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canLiquidateWhilePaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkAndEnableToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkAndOptimizeEnabledTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkEmergencyPausable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "closeCreditAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collateralTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collateralTokensByMask",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collateralTokensCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "contractToAdapter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "creditAccounts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "creditConfigurator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "creditFacade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cumulativeDropAtFastCheckRAY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disableToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enabledTokensMap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fastCollateralCheck",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fees", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "forbiddenTokenMask",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fullCollateralCheck",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCreditAccountOrRevert",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidationThresholds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "manageDebt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "maxAllowedEnabledTokenLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "openCreditAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pool", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "poolService",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "priceOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenMasksMap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferAccountOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "underlying", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "universalAdapter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "wethAddress",
    data: BytesLike
  ): Result;
}

export namespace ExecuteOrderEvent {
  export type InputTuple = [borrower: AddressLike, target: AddressLike];
  export type OutputTuple = [borrower: string, target: string];
  export interface OutputObject {
    borrower: string;
    target: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NewConfiguratorEvent {
  export type InputTuple = [newConfigurator: AddressLike];
  export type OutputTuple = [newConfigurator: string];
  export interface OutputObject {
    newConfigurator: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface ICreditManagerV2 extends BaseContract {
  connect(runner?: ContractRunner | null): ICreditManagerV2;
  waitForDeployment(): Promise<this>;

  interface: ICreditManagerV2Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  adapterToContract: TypedContractMethod<
    [adapter: AddressLike],
    [string],
    "view"
  >;

  addCollateral: TypedContractMethod<
    [
      payer: AddressLike,
      creditAccount: AddressLike,
      token: AddressLike,
      amount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  approveCreditAccount: TypedContractMethod<
    [
      borrower: AddressLike,
      targetContract: AddressLike,
      token: AddressLike,
      amount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  calcClosePayments: TypedContractMethod<
    [
      totalValue: BigNumberish,
      closureActionType: BigNumberish,
      borrowedAmount: BigNumberish,
      borrowedAmountWithInterest: BigNumberish
    ],
    [
      [bigint, bigint, bigint, bigint] & {
        amountToPool: bigint;
        remainingFunds: bigint;
        profit: bigint;
        loss: bigint;
      }
    ],
    "view"
  >;

  calcCreditAccountAccruedInterest: TypedContractMethod<
    [creditAccount: AddressLike],
    [
      [bigint, bigint, bigint] & {
        borrowedAmount: bigint;
        borrowedAmountWithInterest: bigint;
        borrowedAmountWithInterestAndFees: bigint;
      }
    ],
    "view"
  >;

  canLiquidateWhilePaused: TypedContractMethod<
    [arg0: AddressLike],
    [boolean],
    "view"
  >;

  checkAndEnableToken: TypedContractMethod<
    [creditAccount: AddressLike, token: AddressLike],
    [void],
    "nonpayable"
  >;

  checkAndOptimizeEnabledTokens: TypedContractMethod<
    [creditAccount: AddressLike],
    [void],
    "nonpayable"
  >;

  checkEmergencyPausable: TypedContractMethod<
    [caller: AddressLike, state: boolean],
    [boolean],
    "nonpayable"
  >;

  closeCreditAccount: TypedContractMethod<
    [
      borrower: AddressLike,
      closureActionType: BigNumberish,
      totalValue: BigNumberish,
      payer: AddressLike,
      to: AddressLike,
      skipTokenMask: BigNumberish,
      convertWETH: boolean
    ],
    [bigint],
    "nonpayable"
  >;

  collateralTokens: TypedContractMethod<
    [id: BigNumberish],
    [[string, bigint] & { token: string; liquidationThreshold: bigint }],
    "view"
  >;

  collateralTokensByMask: TypedContractMethod<
    [tokenMask: BigNumberish],
    [[string, bigint] & { token: string; liquidationThreshold: bigint }],
    "view"
  >;

  collateralTokensCount: TypedContractMethod<[], [bigint], "view">;

  contractToAdapter: TypedContractMethod<
    [targetContract: AddressLike],
    [string],
    "view"
  >;

  creditAccounts: TypedContractMethod<
    [borrower: AddressLike],
    [string],
    "view"
  >;

  creditConfigurator: TypedContractMethod<[], [string], "view">;

  creditFacade: TypedContractMethod<[], [string], "view">;

  cumulativeDropAtFastCheckRAY: TypedContractMethod<
    [creditAccount: AddressLike],
    [bigint],
    "view"
  >;

  disableToken: TypedContractMethod<
    [creditAccount: AddressLike, token: AddressLike],
    [boolean],
    "nonpayable"
  >;

  enabledTokensMap: TypedContractMethod<
    [creditAccount: AddressLike],
    [bigint],
    "view"
  >;

  executeOrder: TypedContractMethod<
    [borrower: AddressLike, targetContract: AddressLike, data: BytesLike],
    [string],
    "nonpayable"
  >;

  fastCollateralCheck: TypedContractMethod<
    [
      creditAccount: AddressLike,
      tokenIn: AddressLike,
      tokenOut: AddressLike,
      balanceInBefore: BigNumberish,
      balanceOutBefore: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  fees: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint] & {
        feeInterest: bigint;
        feeLiquidation: bigint;
        liquidationDiscount: bigint;
        feeLiquidationExpired: bigint;
        liquidationDiscountExpired: bigint;
      }
    ],
    "view"
  >;

  forbiddenTokenMask: TypedContractMethod<[], [bigint], "view">;

  fullCollateralCheck: TypedContractMethod<
    [creditAccount: AddressLike],
    [void],
    "nonpayable"
  >;

  getCreditAccountOrRevert: TypedContractMethod<
    [borrower: AddressLike],
    [string],
    "view"
  >;

  liquidationThresholds: TypedContractMethod<
    [token: AddressLike],
    [bigint],
    "view"
  >;

  manageDebt: TypedContractMethod<
    [creditAccount: AddressLike, amount: BigNumberish, increase: boolean],
    [bigint],
    "nonpayable"
  >;

  maxAllowedEnabledTokenLength: TypedContractMethod<[], [bigint], "view">;

  openCreditAccount: TypedContractMethod<
    [borrowedAmount: BigNumberish, onBehalfOf: AddressLike],
    [string],
    "nonpayable"
  >;

  pool: TypedContractMethod<[], [string], "view">;

  poolService: TypedContractMethod<[], [string], "view">;

  priceOracle: TypedContractMethod<[], [string], "view">;

  tokenMasksMap: TypedContractMethod<[token: AddressLike], [bigint], "view">;

  transferAccountOwnership: TypedContractMethod<
    [from: AddressLike, to: AddressLike],
    [void],
    "nonpayable"
  >;

  underlying: TypedContractMethod<[], [string], "view">;

  universalAdapter: TypedContractMethod<[], [string], "view">;

  version: TypedContractMethod<[], [bigint], "view">;

  wethAddress: TypedContractMethod<[], [string], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "adapterToContract"
  ): TypedContractMethod<[adapter: AddressLike], [string], "view">;
  getFunction(
    nameOrSignature: "addCollateral"
  ): TypedContractMethod<
    [
      payer: AddressLike,
      creditAccount: AddressLike,
      token: AddressLike,
      amount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "approveCreditAccount"
  ): TypedContractMethod<
    [
      borrower: AddressLike,
      targetContract: AddressLike,
      token: AddressLike,
      amount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "calcClosePayments"
  ): TypedContractMethod<
    [
      totalValue: BigNumberish,
      closureActionType: BigNumberish,
      borrowedAmount: BigNumberish,
      borrowedAmountWithInterest: BigNumberish
    ],
    [
      [bigint, bigint, bigint, bigint] & {
        amountToPool: bigint;
        remainingFunds: bigint;
        profit: bigint;
        loss: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "calcCreditAccountAccruedInterest"
  ): TypedContractMethod<
    [creditAccount: AddressLike],
    [
      [bigint, bigint, bigint] & {
        borrowedAmount: bigint;
        borrowedAmountWithInterest: bigint;
        borrowedAmountWithInterestAndFees: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "canLiquidateWhilePaused"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "checkAndEnableToken"
  ): TypedContractMethod<
    [creditAccount: AddressLike, token: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "checkAndOptimizeEnabledTokens"
  ): TypedContractMethod<[creditAccount: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "checkEmergencyPausable"
  ): TypedContractMethod<
    [caller: AddressLike, state: boolean],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "closeCreditAccount"
  ): TypedContractMethod<
    [
      borrower: AddressLike,
      closureActionType: BigNumberish,
      totalValue: BigNumberish,
      payer: AddressLike,
      to: AddressLike,
      skipTokenMask: BigNumberish,
      convertWETH: boolean
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "collateralTokens"
  ): TypedContractMethod<
    [id: BigNumberish],
    [[string, bigint] & { token: string; liquidationThreshold: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "collateralTokensByMask"
  ): TypedContractMethod<
    [tokenMask: BigNumberish],
    [[string, bigint] & { token: string; liquidationThreshold: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "collateralTokensCount"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "contractToAdapter"
  ): TypedContractMethod<[targetContract: AddressLike], [string], "view">;
  getFunction(
    nameOrSignature: "creditAccounts"
  ): TypedContractMethod<[borrower: AddressLike], [string], "view">;
  getFunction(
    nameOrSignature: "creditConfigurator"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "creditFacade"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "cumulativeDropAtFastCheckRAY"
  ): TypedContractMethod<[creditAccount: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "disableToken"
  ): TypedContractMethod<
    [creditAccount: AddressLike, token: AddressLike],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "enabledTokensMap"
  ): TypedContractMethod<[creditAccount: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "executeOrder"
  ): TypedContractMethod<
    [borrower: AddressLike, targetContract: AddressLike, data: BytesLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fastCollateralCheck"
  ): TypedContractMethod<
    [
      creditAccount: AddressLike,
      tokenIn: AddressLike,
      tokenOut: AddressLike,
      balanceInBefore: BigNumberish,
      balanceOutBefore: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "fees"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint] & {
        feeInterest: bigint;
        feeLiquidation: bigint;
        liquidationDiscount: bigint;
        feeLiquidationExpired: bigint;
        liquidationDiscountExpired: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "forbiddenTokenMask"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "fullCollateralCheck"
  ): TypedContractMethod<[creditAccount: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getCreditAccountOrRevert"
  ): TypedContractMethod<[borrower: AddressLike], [string], "view">;
  getFunction(
    nameOrSignature: "liquidationThresholds"
  ): TypedContractMethod<[token: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "manageDebt"
  ): TypedContractMethod<
    [creditAccount: AddressLike, amount: BigNumberish, increase: boolean],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "maxAllowedEnabledTokenLength"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "openCreditAccount"
  ): TypedContractMethod<
    [borrowedAmount: BigNumberish, onBehalfOf: AddressLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "pool"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "poolService"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "priceOracle"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "tokenMasksMap"
  ): TypedContractMethod<[token: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "transferAccountOwnership"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "underlying"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "universalAdapter"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "version"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "wethAddress"
  ): TypedContractMethod<[], [string], "view">;

  getEvent(
    key: "ExecuteOrder"
  ): TypedContractEvent<
    ExecuteOrderEvent.InputTuple,
    ExecuteOrderEvent.OutputTuple,
    ExecuteOrderEvent.OutputObject
  >;
  getEvent(
    key: "NewConfigurator"
  ): TypedContractEvent<
    NewConfiguratorEvent.InputTuple,
    NewConfiguratorEvent.OutputTuple,
    NewConfiguratorEvent.OutputObject
  >;

  filters: {
    "ExecuteOrder(address,address)": TypedContractEvent<
      ExecuteOrderEvent.InputTuple,
      ExecuteOrderEvent.OutputTuple,
      ExecuteOrderEvent.OutputObject
    >;
    ExecuteOrder: TypedContractEvent<
      ExecuteOrderEvent.InputTuple,
      ExecuteOrderEvent.OutputTuple,
      ExecuteOrderEvent.OutputObject
    >;

    "NewConfigurator(address)": TypedContractEvent<
      NewConfiguratorEvent.InputTuple,
      NewConfiguratorEvent.OutputTuple,
      NewConfiguratorEvent.OutputObject
    >;
    NewConfigurator: TypedContractEvent<
      NewConfiguratorEvent.InputTuple,
      NewConfiguratorEvent.OutputTuple,
      NewConfiguratorEvent.OutputObject
    >;
  };
}
